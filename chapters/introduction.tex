\chapter{简介}\label{introduction1}

\section{Modelica概述}\label{overview-of-modelica}

Modelica是一种用于信息物理系统建模的语言，支持由数学方程控制的组件之间的因果联系，以促进从基本原理建模。
它提供了面向对象的结构，便于模型的重用，并且可以方便地用于复杂系统的建模，包括机械、电气、电子、磁性、液压、热、控制、电力或面向过程的子组件。

\section{规范范围}\label{scope-of-the-specification}

Modelica语言的语义是通过一组规则来指定的，这些规则用于将Modelica语言中描述的任何类转换为扁平的Modelica结构。
语义规范应该与Modelica语法一起阅读。

旨在自行模拟的类 (of specialized class \lstinline!model!, \lstinline!class! or \lstinline!block!) 称为 \firstuse{模拟模型}。

扁平的Modelica结构也被定义用于仿真模型以外的其他情况;包括函数(可用于提供算法内容)、包(用作结构机制)和部分模型(用作基础模型)。
这允许在使用这些类构建仿真模型之前验证它们的正确性。

仿真模型有特定的语义限制，以确保模型的完整性;它们允许其平坦的Modelica结构进一步转化为一组微分、代数和离散方程(=平坦混合DAE)。
请注意，满足语义限制并不保证模型可以从初始条件初始化和模拟。

Modelica的设计是为了促进模型的符号转换，特别是通过将基本上每一种Modelica语言构造映射到平面Modelica结构中的方程。
许多Modelica模型，特别是在相关的Modelica标准库中，是更高的指标系统，只有进行符号指标约简，即微分方程和选择适当的变量作为状态，才能合理地模拟。这样得到的方程组可以转化为状态空间形式(至少在局部数值上)，即指标为零的混合DAE。
为了允许这种结构分析，如果在翻译过程中参数不能被评估，工具可能会拒绝模拟模型——由于调用外部函数或初始方程/初始算法的 \lstinline!fixed = false! 参数。
接受这样的模型是一个实现质量问题。
Modelica规范没有定义如何模拟模型。
但是，它定义了一组模拟结果应该尽可能满足的方程。

翻译(或扁平化)的关键问题是:
\begin{itemize}
\item
  扩展继承的基类
\item
  基类、局部类和组件的参数化
\item
  从 \lstinline!connect!-equations 生成连接方程
\end{itemize}

扁平混合 DAE 形式包括：
\begin{itemize}
\item
  用适当的基本类型、前缀和属性声明变量，例如 \lstinline!parameter Real v = 5!。
\item
  方程部分中的方程。
\item
  函数调用，调用被视为一组方程，其中包括所有输入变量和所有结果变量(方程的数量=基本结果变量的数量)。
\item
  算法部分，每个部分被视为一组方程，其中涉及到在算法部分中出现的变量(方程的数量=分配的不同变量的数量)。
\item
  在 \lstinline!when! -子句中，每个 \lstinline!when! -子句都被视为一组条件赋值方程，这些方程是子句中出现的变量的函数(方程的数量=分配的不同变量的数量)。
\end{itemize}

因此，扁平混合DAE被看作是一组方程，其中一些方程只是有条件地求值。
模型的初始设置是使用\lstinline!start!-attribute和方程来指定的，它们只在初始化期间成立。

Modelica类也可以包含注释，即正式的注释，它指定类的图形表示(图标和图)、类的文档文本和版本信息。

\section{有关定义}\label{some-definitions}

Explanations of many terms can be found using the document index in \cref{document-index}.
Some important terms are defined below.

\begin{definition}[Component]\index{component}
An element defined by the production \lstinline[language=grammar]!component-clause! in the Modelica grammar (basically a variable or an instance of a class)
\end{definition}

\begin{definition}[Element]\index{element}
Class definition, \lstinline!extends!-clause, or \lstinline[language=grammar]!component-clause! declared in a class (basically a class reference or a component in a declaration).
\end{definition}

\begin{definition}[Flattening]\index{flattening}
The translation of a model described in Modelica to the corresponding model described as a hybrid DAE, involving expansion of inherited base classes, parameterization of base classes, local classes
and components, and generation of connection equations from \lstinline!connect!-equations (basically, mapping the hierarchical structure of a model into a set of differential, algebraic and discrete equations together with the corresponding variable declarations and function definitions from the model).
\end{definition}

% More terms that would be useful to define here:
% - translation (for phrases such as "during translation")
% - deprecated
% - quality of implementation
% - simulator

\section{Notation}\label{notation}

The remainder of this section shows examples of the presentation used in this document.

Syntax highlighting of Modelica code is illustrated by the code listing below.
Things to note include keywords that define code structure such as \lstinline!equation!, keywords that do not define code structure such as \lstinline!connect!, and recognized identifiers with meaning defined by the specification such as \lstinline!semiLinear!:
\begin{lstlisting}[language=modelica]
model Example "Example used to illustrate syntax highlighting"
  /* The string above is a class description string, this is a comment. */
  /* Invalid code is typically presented like this: */
  String s = 1.0; // Error: No conversion form Real to String.
  Real x;
equation
  2 * x = semiLinear(time - 0.5, 2, 3);
  /* The annotation below has omitted details represented by an ellipsis: */
  connect(resistor.n, conductor.p) annotation($\ldots$);
end Example;
\end{lstlisting}

Relying on implicit conversion of \lstinline!Integer! literals to \lstinline!Real! is common, as seen in the equation above (note use of Modelica code appearing inline in the text).

It is common to mix Modelica code with mathematical notation.
For example, \lstinline!average($x$, $y$)! could be defined as $\frac{x + y}{2}$.

\begin{definition}[Something]% Do not add this one to the index!
Text defining the meaning of \emph{something}.
\end{definition}

In addition to the style of definition above, new terminology can be introduced in the running text.
% TODO: Switch to \firstuse[---]{dummy} below.  For now, using \willintroduce to avoid risk of accidentally
% creating index entry in the future.
For example, a \willintroduce{dummy} is something that\ldots

\begin{nonnormative}
This is non-normative content that provides some explanation, motivation, and/or additional things to keep in mind.
It has no defining power and may be skipped by readers strictly interested in just the definition of the Modelica language.
\end{nonnormative}

\begin{example}
This is an example, which is a special kind of non-normative content.
Examples often contain a mix of code listings and explanatory text, and this is no exception:
\begin{lstlisting}[language=modelica]
String s = 1.0; // Error: No conversion form Real to String.
\end{lstlisting}
To fix the type mismatch above, the number has to be replaced by a \lstinline!String! expression, such as \lstinline!"1.0"!.
\end{example}

Other code listings in the document include specification of lexical units and grammatical structure, both using metasymbols of the extended BNF-grammar defined in~\cref{lexical-conventions}.
Lexical units are named with all upper-case letters and introduced with the `\lstinline[language=grammar]!=!' sign:
\begin{lstlisting}[language=grammar]
SOME-TOKEN = NON-DIGIT { DIGIT | NON-DIGIT }
\end{lstlisting}
Grammatical structure is recognized by production rules being named with lower-case letters and introduced with the `\lstinline[language=grammar]!:!' sign (also note appearance of the Modelica keyword \lstinline!der!):
\begin{lstlisting}[language=grammar]
differentiated-expression :
    der "(" SOME-TOKEN ")"
    | "(" differentiated-expression "+" differentiated-expression ")"
\end{lstlisting}
